#include<iostream>
#include<fstream>
#include<string>
#include<cstring>

using namespace std;

struct Ticket{
  char rut_funcionario[10];
  int day_of_month;
  char time[6];
};

struct Servicios{
  string nombre;
  int ticket_diario;
  int ticket_mensual;
  char inicio_servicio[6];
  char fin_servicio[6];
};

/*****
* Servicios* lecturaArchivoASCII 
******
* La funcion realiza una lectura de un archivo ASCII y lo almacena en un struct
******
* Input:
* int &num_servicios: trabaja con la dirección de memoria de num_servicios
* 
******
* Return:
* Puntero, retorna el puntero utilizado en el llenado del struct Servicios
*****/
Servicios* lecturaArchivoASCII(int &num_servicios){
  int i=0;
  ifstream archivo;
  archivo.open("servicios.txt");
  if(!archivo.is_open()){
    cout<<"El archivo no ha podido ser leído";
  }
  archivo>>num_servicios;
  Servicios* servicios;
  servicios = new Servicios[num_servicios];
  for(i=0;i<num_servicios;i++){
    archivo>>servicios[i].nombre;
    archivo>>servicios[i].ticket_diario;
    archivo>>servicios[i].ticket_mensual;
    archivo>>servicios[i].inicio_servicio;
    archivo>>servicios[i].fin_servicio;
  }
  archivo.close();
  return servicios;
}

/*****
* Ticket lecturaArchivoBin
******
* La funcion realiza una lectura al archivo binario y lo almacena en struct
******
* Input:
* int &cantidad_de_tickets: trabaja con la dirección de memoria del int cantidad_de_tickets
* 
******
* Return:
* Puntero, retorna el puntero utilizado en el llenado del struct Ticket
*****/
Ticket* lecturaArchivoBin(int &cantidad_de_tickets){
  Ticket *tickets;
  ifstream archivo;
  archivo.open("tickets.dat",ios::binary);
  if(!archivo.is_open()){
    cout<<"El archivo no ha podido ser leído";
  }
  archivo.read((char *)&cantidad_de_tickets, sizeof(int));
  tickets = new Ticket[cantidad_de_tickets]; 
  archivo.read((char *)tickets,sizeof(Ticket)*cantidad_de_tickets);
  archivo.close();
  return tickets;
}

/*****
* int contar_validos
******
* La funcion cuenta los tickets validos para un rut específico
******
* string rut: rut específico
* string* ruts: arreglo de ruts asignado en main
* int &validos_totales: cantidad de tickets validos en general
* 
******
* Return:
* int, retorna la cantidad de validos
*****/
int contar_validos(string rut, string* ruts, int &validos_totales){
  int validos=0, i;
  for(i = 0; i< validos_totales; i++){
    if(rut==ruts[i]){
      validos++;
    }
  }
  return validos;
}

/*****
* int contar_totales
******
* La funcion realiza un conteo de los tickets validos e invalidos para un rut específico
******
* Input:
* struct Ticket
* string rut definido en el main
* int cantidad_de_tickets
******
* Return:
* Puntero, retorna el puntero utilizado en el llenado del struct Ticket
*****/  
int contar_totales(string rut, Ticket* tickets, int cantidad_de_tickets){
  int totales = 0, j;
  for(j = 0; j < cantidad_de_tickets; j++){
    if (rut==tickets[j].rut_funcionario){
      totales++;
    }
  }
  return totales;
}

/*****
* void ordenar_ruts
******
* La funcion ordena los ruts lexicograficamente e imprime la cantidad de tickets validos junto a la cantidad de tickets totales para todos los ruts.
******
* Input:
* struct Ticket
* string* ruts: ruts que poseen los tickets validos
* int &validos_totales: cantidad de tickets validos totales
* int cantidad_de_tickets: cantidad de tickets existentes
*
******
* Return:
* Al ser tipo void, no tiene un retorno.
*****/
void ordenar_ruts(Ticket* tickets, string* ruts, int &validos_totales, int cantidad_de_tickets){
  int i,j;
  string ruts_orden[cantidad_de_tickets],aux_orden,rut;
  for(i=0;i<cantidad_de_tickets;i++){
    ruts_orden[i] = tickets[i].rut_funcionario;
  }
  for(i=0;i<cantidad_de_tickets;i++){
    for(j=0;j<cantidad_de_tickets-1;j++){
      if(ruts_orden[j]>ruts_orden[j+1]){
        aux_orden=ruts_orden[j];
        ruts_orden[j]=ruts_orden[j+1];
        ruts_orden[j+1]=aux_orden;
      }
    }
  }
  bool flag;
  flag = true;
  for (i=0;i < cantidad_de_tickets;i++){
    if(strcmp(rut.c_str(),ruts_orden[i].c_str())!=0){
      rut=ruts_orden[i];
      int t = contar_totales(rut, tickets, cantidad_de_tickets);
      cout<< rut <<" "<<contar_validos(rut, ruts, validos_totales) <<"/"<< t << endl;
    }
  }
}


/*****
* int main
******
* La función main contiene las condiciones para cumplir tickets validos y almacena la cantidad de tickets validos llamando a la funcion ordenar_ruts
******
* Input:
* La función no posee parámetros
* 
******
* Returns:
* return 0: retorna el valor cero
*****/
int main(){
  Ticket* tickets;
  Servicios* servicios;
  int num_servicios, cantidad_de_tickets, i, j;
  int hora_ticket, hora_servicio, hora_fin_servicio, validos_totales=0;
  string aux_ticket, aux_servicio, aux_serviciofin;
  string* ruts;
  servicios = lecturaArchivoASCII(num_servicios);
  tickets = lecturaArchivoBin(cantidad_de_tickets);
  ruts = new string[cantidad_de_tickets];
  for(i = 0; i < cantidad_de_tickets; i++){
    aux_ticket = tickets[i].time[0];
    aux_ticket+=tickets[i].time[1];
    aux_ticket+=tickets[i].time[3];
    aux_ticket+=tickets[i].time[4];
    hora_ticket=stoi(aux_ticket);
    
    for(j=0;j<num_servicios;j++){
      aux_servicio=servicios[j].inicio_servicio[0];
      aux_servicio+=servicios[j].inicio_servicio[1]; 
      aux_servicio+=servicios[j].inicio_servicio[3];
      aux_servicio+=servicios[j].inicio_servicio[4];
      hora_servicio=stoi(aux_servicio);

      aux_serviciofin=servicios[j].fin_servicio[0];
      aux_serviciofin+=servicios[j].fin_servicio[1];
      aux_serviciofin+=servicios[j].fin_servicio[3];
      aux_serviciofin+=servicios[j].fin_servicio[4];
      hora_fin_servicio=stoi(aux_serviciofin);    
      if((hora_fin_servicio > hora_servicio) ? hora_ticket>=hora_servicio && hora_ticket<=hora_fin_servicio : hora_ticket>=hora_servicio || hora_ticket<=hora_fin_servicio ) {
        ruts[validos_totales] = tickets[i].rut_funcionario;
        validos_totales++;
      }
    }
  }
  
  ordenar_ruts(tickets, ruts, validos_totales, cantidad_de_tickets);
  delete[] servicios;
  delete[] tickets;
  delete[] ruts;
  return 0;
}
